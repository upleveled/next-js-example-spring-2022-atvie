"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportInvalidTypeAnnotations = exports.reportIncorrectTypeAnnotations = exports.reportMissingTypeAnnotations = exports.reportPostgresError = exports.reportDuplicateColumns = exports.reportBaseError = exports.reportInvalidQueryError = exports.withTransformType = void 0;
const utils_1 = require("../utils");
function isReplacerFromTo(replacer) {
    return Array.isArray(replacer) && replacer.length === 2;
}
function transformType(typeString, typeReplacer) {
    return isReplacerFromTo(typeReplacer)
        ? typeString.replace(new RegExp(typeReplacer[0], "g"), typeReplacer[1])
        : typeReplacer.replace("${type}", typeString);
}
/**
 * Takes a generated result and a transform type and returns a result with the
 * transformed type.
 *
 * @param transform could be either:
 *  - a string that has ${type} in it,
 *  - an array of tuples that behave as [valueToBeReplaced, typeToReplaceWith]
 *  - an array that has a mix of the above (such as ["${type}[]", ["Nullable", "Maybe"]])
 */
function withTransformType(result, transform) {
    if (transform === undefined || result.result === null) {
        return result;
    }
    if (typeof transform === "string") {
        return Object.assign(Object.assign({}, result), { result: transformType(result.result, transform) });
    }
    const replacer = (() => {
        let transformed = result.result;
        for (const replacer of transform) {
            transformed = transformType(transformed, replacer);
        }
        return transformed;
    })();
    return Object.assign(Object.assign({}, result), { result: replacer });
}
exports.withTransformType = withTransformType;
function reportInvalidQueryError(params) {
    const { context, error } = params;
    return context.report({
        messageId: "invalidQuery",
        node: error.node,
        data: { error: error.message },
    });
}
exports.reportInvalidQueryError = reportInvalidQueryError;
function reportBaseError(params) {
    const { context, tag, error } = params;
    return context.report({
        node: tag,
        messageId: "error",
        data: {
            error: error.message,
        },
    });
}
exports.reportBaseError = reportBaseError;
function reportDuplicateColumns(params) {
    const { tag, context, error } = params;
    return context.report({
        node: tag,
        messageId: "invalidQuery",
        loc: utils_1.ESTreeUtils.getSourceLocationFromStringPosition({
            loc: tag.quasi.loc,
            position: error.queryText.search(error.columns[0]) + 1,
            value: error.queryText,
        }),
        data: {
            error: error.message,
        },
    });
}
exports.reportDuplicateColumns = reportDuplicateColumns;
function reportPostgresError(params) {
    const { context, tag, error } = params;
    return context.report({
        node: tag,
        messageId: "invalidQuery",
        loc: utils_1.ESTreeUtils.getSourceLocationFromStringPosition({
            loc: tag.quasi.loc,
            position: parseInt(error.position, 10),
            value: error.queryText,
        }),
        data: {
            error: error.message,
        },
    });
}
exports.reportPostgresError = reportPostgresError;
function reportMissingTypeAnnotations(params) {
    const { context, tag, baseNode, result } = params;
    return context.report({
        node: tag,
        messageId: "missingTypeAnnotations",
        loc: baseNode.loc,
        fix: (fixer) => fixer.insertTextAfterRange(baseNode.range, `<${result.result}>`),
        data: {
            fix: result.result,
        },
    });
}
exports.reportMissingTypeAnnotations = reportMissingTypeAnnotations;
function reportIncorrectTypeAnnotations(params) {
    const { context, result, typeParameter } = params;
    return context.report({
        node: typeParameter.params[0],
        messageId: "incorrectTypeAnnotations",
        fix: (fixer) => fixer.replaceText(typeParameter, `<${result.result}>`),
        data: {
            expected: params.expected,
            actual: params.actual,
        },
    });
}
exports.reportIncorrectTypeAnnotations = reportIncorrectTypeAnnotations;
function reportInvalidTypeAnnotations(params) {
    const { context, typeParameter } = params;
    return context.report({
        node: typeParameter.params[0],
        messageId: "invalidTypeAnnotations",
    });
}
exports.reportInvalidTypeAnnotations = reportInvalidTypeAnnotations;
//# sourceMappingURL=check-sql.utils.js.map