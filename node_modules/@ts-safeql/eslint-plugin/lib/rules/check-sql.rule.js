"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleOptions = exports.Options = exports.UserConfigFile = exports.Config = void 0;
const shared_1 = require("@ts-safeql/shared");
const utils_1 = require("@typescript-eslint/utils");
const libpg_query_1 = __importDefault(require("libpg-query"));
const synckit_1 = require("synckit");
const ts_pattern_1 = require("ts-pattern");
const zod_1 = __importDefault(require("zod"));
const zod_to_json_schema_1 = __importDefault(require("zod-to-json-schema"));
const utils_2 = require("../utils");
const fp_ts_1 = require("../utils/fp-ts");
const node_utils_1 = require("../utils/node.utils");
const ts_pg_utils_1 = require("../utils/ts-pg.utils");
const ts_utils_1 = require("../utils/ts.utils");
const check_sql_config_1 = require("./check-sql.config");
const check_sql_utils_1 = require("./check-sql.utils");
const messages = {
    typeInferenceFailed: "Type inference failed {{error}}",
    error: "{{error}}",
    invalidQuery: "Invalid Query: {{error}}",
    missingTypeAnnotations: "Query is missing type annotation\n\tFix with: {{fix}}",
    incorrectTypeAnnotations: "Query has incorrect type annotation.\n\tExpected: {{expected}}`\n\tActual: {{actual}}",
    invalidTypeAnnotations: "Query has invalid type annotation (SafeQL does not support it. If you think it should, please open an issue)",
};
const baseSchema = zod_1.default.object({
    /**
     * Transform the end result of the type.
     *
     * For example:
     *  - `"${type}[]"` will transform the type to an array
     *  - `["Nullable", "Maybe"]` will replace `Nullable` with `Maybe` in the type
     *  - `["${type}[]", ["Nullable", "Maybe"]]` will do both
     */
    transform: zod_1.default
        .union([zod_1.default.string(), zod_1.default.array(zod_1.default.union([zod_1.default.string(), zod_1.default.tuple([zod_1.default.string(), zod_1.default.string()])]))])
        .optional(),
    /**
     * Transform the (column) field key. Can be one of the following:
     * - `"snake"` - `user_id` → `userId`
     * - `"camel"` - `user_id` → `userId`
     * - `"pascal"` - `user_id` → `UserId`
     * - `"screaming snake"` - `user_id` → `USER_ID`
     */
    fieldTransform: zod_1.default.enum(["snake", "pascal", "camel", "screaming snake"]).optional(),
    /**
     * Whether or not keep the connection alive. Change it only if you know what you're doing.
     */
    keepAlive: zod_1.default.boolean().optional(),
    /**
     * Override defaults
     */
    overrides: zod_1.default
        .object({
        types: zod_1.default.record(zod_1.default.enum((0, shared_1.objectKeysNonEmpty)(shared_1.defaultTypeMapping)), zod_1.default.string()),
    })
        .partial()
        .optional(),
});
const identifyByNameAndOperators = zod_1.default.object({
    /**
     * The name of the variable the holds the connection.
     *
     * For example "conn" for `conn.query(...)`
     */
    name: zod_1.default.string(),
    /**
     * An array of operator names that executes raw queries inside the variable that holds the connection.
     *
     * For example ["$queryRaw", "$executeRaw"] for `Prisma.$queryRaw(...)` and `Prisma.$executeRaw(...)`
     */
    operators: zod_1.default.array(zod_1.default.string()),
});
const identifyByTagName = zod_1.default.object({
    /**
     * The name of the tag that executes raw queries.
     *
     * For example "sql" for ```` sql`SELECT * FROM users`  ````
     */
    tagName: zod_1.default.string(),
});
const connectByMigrationSchema = zod_1.default.object({
    /**
     * The path where the migration files are located.
     */
    migrationsDir: zod_1.default.string(),
    /**
     * THIS IS NOT THE PRODUCTION DATABASE.
     *
     * A connection url to the database.
     * This is required since in order to run the migrations, a connection to postgres is required.
     * Will be used only to create and drop the shadow database (see `databaseName`).
     */
    connectionUrl: zod_1.default.string().optional(),
    /**
     * The name of the shadow database that will be created from the migration files.
     */
    databaseName: zod_1.default.string(),
});
const connectByDatabaseUrl = zod_1.default.object({
    /**
     * The connection url to the database
     */
    databaseUrl: zod_1.default.string(),
});
const RuleOptionConnection = zod_1.default.union([
    baseSchema.merge(connectByMigrationSchema.merge(identifyByNameAndOperators)),
    baseSchema.merge(connectByMigrationSchema.merge(identifyByTagName)),
    baseSchema.merge(connectByDatabaseUrl.merge(identifyByNameAndOperators)),
    baseSchema.merge(connectByDatabaseUrl.merge(identifyByTagName)),
]);
exports.Config = zod_1.default.object({
    connections: zod_1.default.union([zod_1.default.array(RuleOptionConnection), RuleOptionConnection]),
});
exports.UserConfigFile = zod_1.default.object({ useConfigFile: zod_1.default.boolean() });
exports.Options = zod_1.default.union([exports.Config, exports.UserConfigFile]);
exports.RuleOptions = zod_1.default.array(exports.Options).min(1).max(1);
const workerPath = require.resolve("./check-sql.worker");
const generateSync = (0, synckit_1.createSyncFn)(workerPath, {
    tsRunner: "esbuild-register",
    timeout: 1000 * 60 * 5,
});
function check(params) {
    const connections = Array.isArray(params.config.connections)
        ? params.config.connections
        : [params.config.connections];
    for (const connection of connections) {
        checkConnection(Object.assign(Object.assign({}, params), { connection }));
    }
}
function isTagMemberValid(expr) {
    // For example sql``
    if (utils_2.ESTreeUtils.isIdentifier(expr.tag)) {
        return true;
    }
    // For example Provider.sql``
    if (utils_2.ESTreeUtils.isMemberExpression(expr.tag) && utils_2.ESTreeUtils.isIdentifier(expr.tag.property)) {
        return true;
    }
    return false;
}
function getASTStartegyByConnection(connection) {
    if ("tagName" in connection) {
        return Object.assign({ strategy: "tag" }, connection);
    }
    return Object.assign({ strategy: "call" }, connection);
}
function checkConnection(params) {
    const strategy = getASTStartegyByConnection(params.connection);
    return (0, ts_pattern_1.match)(strategy)
        .with({ strategy: "tag" }, (connection) => {
        return checkConnectionByTagExpression(Object.assign(Object.assign({}, params), { connection }));
    })
        .with({ strategy: "call" }, (connection) => {
        return checkConnectionByCallExpression(Object.assign(Object.assign({}, params), { connection }));
    })
        .exhaustive();
}
const pgParseQueryE = (query) => {
    return (0, fp_ts_1.pipe)(fp_ts_1.E.tryCatch(() => libpg_query_1.default.parseQuerySync(query), (error) => shared_1.PostgresError.to(query, error)));
};
const generateSyncE = (0, fp_ts_1.flow)(generateSync, fp_ts_1.E.chain(fp_ts_1.J.parse), fp_ts_1.E.chainW((parsed) => parsed), fp_ts_1.E.mapLeft((error) => error));
function reportCheck(params) {
    const { context, tag, connection, projectDir, typeParameter, baseNode } = params;
    return (0, fp_ts_1.pipe)(fp_ts_1.E.Do, fp_ts_1.E.bind("parser", () => fp_ts_1.E.of(utils_1.ESLintUtils.getParserServices(context))), fp_ts_1.E.bind("checker", ({ parser }) => fp_ts_1.E.of(parser.program.getTypeChecker())), fp_ts_1.E.bind("query", ({ parser, checker }) => (0, ts_pg_utils_1.mapTemplateLiteralToQueryText)(tag.quasi, parser, checker)), fp_ts_1.E.bindW("pgParsed", ({ query }) => pgParseQueryE(query)), fp_ts_1.E.bindW("result", ({ query, pgParsed }) => generateSyncE({ query, pgParsed, connection, projectDir })), fp_ts_1.E.fold((error) => {
        return (0, ts_pattern_1.match)(error)
            .with({ _tag: "DuplicateColumnsError" }, (error) => {
            return (0, check_sql_utils_1.reportDuplicateColumns)({ context, error, tag });
        })
            .with({ _tag: "PostgresError" }, (error) => {
            return (0, check_sql_utils_1.reportPostgresError)({ context, error, tag });
        })
            .with({ _tag: "InvalidQueryError" }, (error) => {
            return (0, check_sql_utils_1.reportInvalidQueryError)({ context, error });
        })
            .with({ _tag: "InvalidMigrationError" }, { _tag: "InvalidMigrationsPathError" }, { _tag: "DatabaseInitializationError" }, { _tag: "InternalError" }, (error) => {
            return (0, check_sql_utils_1.reportBaseError)({ context, error, tag });
        })
            .exhaustive();
    }, ({ result, checker, parser }) => {
        const isMissingTypeAnnotations = typeParameter === undefined;
        const resultWithTransformed = (0, check_sql_utils_1.withTransformType)(result, connection.transform);
        if (isMissingTypeAnnotations) {
            return (0, check_sql_utils_1.reportMissingTypeAnnotations)({
                tag: tag,
                context: context,
                baseNode: baseNode,
                result: resultWithTransformed,
            });
        }
        const typeAnnotationState = getTypeAnnotationState({
            result: resultWithTransformed,
            typeParameter: typeParameter,
            checker: checker,
            parser: parser,
        });
        if (typeAnnotationState === "INVALID" || typeAnnotationState === "UNKNOWN") {
            return (0, check_sql_utils_1.reportInvalidTypeAnnotations)({
                context: context,
                typeParameter: typeParameter,
            });
        }
        if (!typeAnnotationState.isEqual) {
            return (0, check_sql_utils_1.reportIncorrectTypeAnnotations)({
                context,
                result: resultWithTransformed,
                typeParameter: typeParameter,
                expected: typeAnnotationState.current,
                actual: typeAnnotationState.generated,
            });
        }
    }));
}
function checkConnectionByTagExpression(params) {
    const { context, tag, projectDir, connection } = params;
    if ((utils_2.ESTreeUtils.isIdentifier(tag.tag) && tag.tag.name === connection.tagName) ||
        (utils_2.ESTreeUtils.isMemberExpression(tag.tag) &&
            utils_2.ESTreeUtils.isIdentifier(tag.tag.object) &&
            utils_2.ESTreeUtils.isIdentifier(tag.tag.property) &&
            utils_2.ESTreeUtils.isEqual(connection.tagName, `${tag.tag.object.name}.${tag.tag.property.name}`))) {
        return reportCheck({
            context,
            tag,
            connection,
            projectDir,
            baseNode: tag.tag,
            typeParameter: tag.typeParameters,
        });
    }
}
function checkConnectionByCallExpression(params) {
    const { context, tag, projectDir, connection } = params;
    if (isTagMemberValid(tag) &&
        utils_2.ESTreeUtils.isCallExpression(tag.parent) &&
        utils_2.ESTreeUtils.isMemberExpression(tag.parent.callee) &&
        utils_2.ESTreeUtils.isIdentifier(tag.parent.callee.object) &&
        utils_2.ESTreeUtils.isEqual(tag.parent.callee.object.name, connection.name) &&
        utils_2.ESTreeUtils.isIdentifier(tag.parent.callee.property) &&
        utils_2.ESTreeUtils.isOneOf(tag.parent.callee.property.name, connection.operators)) {
        return reportCheck({
            context,
            tag,
            connection,
            projectDir,
            baseNode: tag.parent.callee,
            typeParameter: tag.parent.typeParameters,
        });
    }
}
function getTypeAnnotationState(params) {
    const { result: { result }, typeParameter, parser, checker, } = params;
    if (typeParameter.params.length !== 1) {
        return "INVALID";
    }
    const typeNode = typeParameter.params[0];
    const current = (0, ts_utils_1.tsTypeToText)({ checker, parser, typeNode });
    if (current === "UNKNOWN") {
        return "UNKNOWN";
    }
    return getTypesEquality(current, result);
}
// TODO this should be improved.
function getTypesEquality(current, generated) {
    if (current === null && generated === null) {
        return { isEqual: true, current, generated };
    }
    if (current === null || generated === null) {
        return { isEqual: false, current, generated };
    }
    const omitRegex = /[\n ;]/g;
    const isEqual = current.replace(omitRegex, "") === generated.replace(omitRegex, "");
    return { isEqual, current, generated };
}
const createRule = (utils_1.ESLintUtils.RuleCreator(() => `https://github.com/ts-safeql/safeql`));
exports.default = createRule({
    name: "check-sql",
    meta: {
        fixable: "code",
        docs: {
            description: "Ensure that sql queries have type annotations",
            recommended: "error",
            suggestion: true,
            requiresTypeChecking: false,
        },
        messages: messages,
        type: "problem",
        schema: (0, zod_to_json_schema_1.default)(exports.RuleOptions, { target: "openApi3" }),
    },
    defaultOptions: [],
    create(context) {
        const projectDir = (0, node_utils_1.locateNearestPackageJsonDir)(context.getFilename());
        const config = (0, check_sql_config_1.getConfigFromFileWithContext)({ context, projectDir });
        return {
            TaggedTemplateExpression(tag) {
                check({ context, tag, config, projectDir });
            },
        };
    },
});
//# sourceMappingURL=check-sql.rule.js.map