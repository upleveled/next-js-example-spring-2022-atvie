"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapTemplateLiteralToQueryText = void 0;
const shared_1 = require("@ts-safeql/shared");
const fp_ts_1 = require("fp-ts");
const function_1 = require("fp-ts/lib/function");
const typescript_1 = __importDefault(require("typescript"));
function mapTemplateLiteralToQueryText(quasi, parser, checker) {
    let $idx = 0;
    let $queryText = "";
    for (const $quasi of quasi.quasis) {
        $queryText += $quasi.value.raw;
        if ($quasi.tail) {
            break;
        }
        const expression = quasi.expressions[$idx];
        const pgType = (0, function_1.pipe)(mapExpressionToTsTypeString({ expression, parser, checker }), mapTsTypeStringToPgType);
        if (fp_ts_1.either.isLeft(pgType)) {
            return fp_ts_1.either.left(shared_1.InvalidQueryError.of(pgType.left, expression));
        }
        const pgTypeValue = pgType.right;
        $queryText += `$${++$idx}::${pgTypeValue}`;
    }
    return fp_ts_1.either.right($queryText);
}
exports.mapTemplateLiteralToQueryText = mapTemplateLiteralToQueryText;
function mapExpressionToTsTypeString(params) {
    const tsNode = params.parser.esTreeNodeToTSNodeMap.get(params.expression);
    const tsType = params.checker.getTypeAtLocation(tsNode);
    return {
        node: tsNode,
        type: tsType,
        checker: params.checker,
    };
}
const tsTypeToPgTypeMap = {
    number: "int",
    string: "text",
    boolean: "boolean",
    bigint: "bigint",
    any: "text",
    unknown: "text",
};
const tsKindToPgTypeMap = {
    [typescript_1.default.SyntaxKind.StringLiteral]: "text",
    [typescript_1.default.SyntaxKind.NumericLiteral]: "int",
    [typescript_1.default.SyntaxKind.TrueKeyword]: "boolean",
    [typescript_1.default.SyntaxKind.FalseKeyword]: "boolean",
    [typescript_1.default.SyntaxKind.BigIntLiteral]: "bigint",
};
const tsFlagToPgTypeMap = {
    [typescript_1.default.TypeFlags.String]: "text",
    [typescript_1.default.TypeFlags.Number]: "int",
    [typescript_1.default.TypeFlags.Boolean]: "boolean",
    [typescript_1.default.TypeFlags.BigInt]: "bigint",
    [typescript_1.default.TypeFlags.NumberLiteral]: "int",
    [typescript_1.default.TypeFlags.StringLiteral]: "text",
    [typescript_1.default.TypeFlags.BooleanLiteral]: "boolean",
    [typescript_1.default.TypeFlags.BigIntLiteral]: "bigint",
};
function mapTsTypeStringToPgType(params) {
    if (params.node.kind === typescript_1.default.SyntaxKind.ConditionalExpression) {
        const whenTrue = params.checker.getTypeAtLocation(params.node.whenTrue);
        const whenTrueType = tsFlagToPgTypeMap[whenTrue.flags];
        const whenFalse = params.checker.getTypeAtLocation(params.node.whenFalse);
        const whenFalseType = tsFlagToPgTypeMap[whenFalse.flags];
        if (whenTrueType === undefined || whenFalseType === undefined) {
            return fp_ts_1.either.left(`Unsupported conditional expression flags (true = ${whenTrue.flags}, false = ${whenFalse.flags})`);
        }
        if (whenTrueType !== whenFalseType) {
            return fp_ts_1.either.left(`Conditional expression must have the same type (true = ${whenTrueType}, false = ${whenFalseType})`);
        }
        return fp_ts_1.either.right(whenTrueType);
    }
    if (params.node.kind in tsKindToPgTypeMap) {
        return fp_ts_1.either.right(tsKindToPgTypeMap[params.node.kind]);
    }
    if (params.type.flags in tsFlagToPgTypeMap) {
        return fp_ts_1.either.right(tsFlagToPgTypeMap[params.type.flags]);
    }
    const typeStr = params.checker.typeToString(params.type);
    const singularType = typeStr.replace(/\[\]$/, "");
    const isArray = typeStr !== singularType;
    const isSignularTypeSupported = singularType in tsTypeToPgTypeMap;
    if (isSignularTypeSupported) {
        return isArray
            ? fp_ts_1.either.right(`${tsTypeToPgTypeMap[singularType]}[]`)
            : fp_ts_1.either.right(tsTypeToPgTypeMap[singularType]);
    }
    return fp_ts_1.either.left(`the type "${typeStr}" is not supported`);
}
//# sourceMappingURL=ts-pg.utils.js.map