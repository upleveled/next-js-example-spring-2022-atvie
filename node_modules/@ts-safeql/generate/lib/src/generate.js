"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = exports.getMetadataFromCacheOrFetch = void 0;
const shared_1 = require("@ts-safeql/shared");
const fp_ts_1 = require("fp-ts");
const postgres_1 = require("postgres");
require("source-map-support/register");
const getLeftJoinTables_1 = require("./utils/getLeftJoinTables");
const $cacheMap = new Map();
async function getDatabaseMetadata(sql) {
    const pgTypes = await getPgTypes(sql);
    const pgCols = await getPgCols(sql);
    const pgColsByTableOidCache = (0, shared_1.groupBy)(pgCols, "tableOid");
    return { pgTypes, pgCols, pgColsByTableOidCache };
}
async function getMetadataFromCacheOrFetch(sql, cacheKey) {
    const cache = $cacheMap.get(cacheKey);
    if (cache !== undefined) {
        return cache;
    }
    const cacheValue = await getDatabaseMetadata(sql);
    $cacheMap.set(cacheKey, cacheValue);
    return cacheValue;
}
exports.getMetadataFromCacheOrFetch = getMetadataFromCacheOrFetch;
async function generate(params) {
    var _a;
    const { sql, query, cacheMetadata = true } = params;
    const { pgCols, pgColsByTableOidCache, pgTypes } = cacheMetadata
        ? await getMetadataFromCacheOrFetch(sql, params.cacheKey)
        : await getDatabaseMetadata(sql);
    try {
        const result = await sql.unsafe(query, [], { prepare: true }).describe();
        if (result.columns === undefined || result.columns === null || result.columns.length === 0) {
            return fp_ts_1.either.right({ result: null, stmt: result, query: query });
        }
        const duplicateCols = result.columns.filter((col, index) => result.columns.find((c, i) => c.name === col.name && i != index));
        if (duplicateCols.length > 0) {
            const dupes = duplicateCols.map((col) => ({
                table: pgColsByTableOidCache.get(col.table).find((c) => c.colName === col.name).tableName,
                column: col.name,
            }));
            return fp_ts_1.either.left(shared_1.DuplicateColumnsError.of({
                queryText: query,
                columns: dupes.map((x) => `${x.table}.${x.column}`),
            }));
        }
        const leftTables = (0, getLeftJoinTables_1.getLeftJoinTablesFromParsed)(params.pgParsed).map((tableName) => pgCols.find((col) => col.tableName === tableName).tableOid);
        const columns = result.columns.map((col) => {
            var _a;
            const introspected = (_a = pgColsByTableOidCache
                .get(col.table)) === null || _a === void 0 ? void 0 : _a.find((x) => x.colNum === col.number);
            return introspected === undefined ? { described: col } : { described: col, introspected };
        });
        const typesMap = Object.assign(Object.assign({}, shared_1.defaultTypeMapping), (_a = params.overrides) === null || _a === void 0 ? void 0 : _a.types);
        return fp_ts_1.either.right({
            result: mapColumnAnalysisResultsToTypeLiteral({
                columns,
                pgTypes,
                leftTables,
                typesMap,
                fieldTransform: params.fieldTransform,
            }),
            stmt: result,
            query: query,
        });
    }
    catch (e) {
        if (e instanceof postgres_1.PostgresError) {
            return fp_ts_1.either.left(shared_1.PostgresError.of({
                queryText: query,
                message: e.message,
                line: e.line,
                position: e.position,
            }));
        }
        throw e;
    }
}
exports.generate = generate;
function mapColumnAnalysisResultsToTypeLiteral(params) {
    const properties = params.columns.map((col) => {
        const propertySignature = mapColumnAnalysisResultToPropertySignature({
            col,
            pgTypes: params.pgTypes,
            leftTables: params.leftTables,
            typesMap: params.typesMap,
            fieldTransform: params.fieldTransform,
        });
        return `${propertySignature};`;
    });
    return `{ ${properties.join(" ")} }`;
}
function buildInterfacePropertyValue(params) {
    return `${params.key}: ${params.isNullable ? `Nullable<${params.value}>` : params.value}`;
}
function mapColumnAnalysisResultToPropertySignature(params) {
    var _a;
    if ("introspected" in params.col) {
        const tsType = params.typesMap[params.col.introspected.colType];
        const value = params.col.introspected.colNotNull ? tsType : `Nullable<${tsType}>`;
        const isFromLeftJoin = params.leftTables.includes(params.col.introspected.tableOid);
        const key = (_a = params.col.described.name) !== null && _a !== void 0 ? _a : params.col.introspected.colName;
        return buildInterfacePropertyValue({
            key: (0, shared_1.toCase)(key, params.fieldTransform),
            value: value,
            isNullable: isFromLeftJoin,
        });
    }
    const nonTableColumnType = getTsTypeFromPgTypeOid({
        pgTypeOid: params.col.described.type,
        pgTypes: params.pgTypes,
        typesMap: params.typesMap,
    });
    return buildInterfacePropertyValue({
        key: (0, shared_1.toCase)(params.col.described.name, params.fieldTransform),
        value: nonTableColumnType,
        isNullable: false,
    });
}
function getTsTypeFromPgTypeOid(params) {
    const pgType = params.pgTypes.find((type) => type.oid === params.pgTypeOid);
    if (pgType === undefined) {
        return "unknown";
    }
    return getTsTypeFromPgType({ pgTypeName: pgType.name, typesMap: params.typesMap });
}
function getTsTypeFromPgType(params) {
    var _a;
    const { isArray, pgType } = parsePgType(params.pgTypeName);
    const tsType = (_a = params.typesMap[pgType]) !== null && _a !== void 0 ? _a : "any";
    return isArray ? `Array<${tsType}>` : tsType;
}
function isPgTypeArray(pgType) {
    return pgType.startsWith("_");
}
function parsePgType(pgType) {
    const isArray = isPgTypeArray(pgType);
    return {
        isArray: isArray,
        pgType: isArray ? pgType.slice(1) : pgType,
    };
}
async function getPgTypes(sql) {
    const rows = await sql `
        SELECT oid, typname as name FROM pg_type
    `;
    return rows;
}
async function getPgCols(sql) {
    const rows = await sql `
        SELECT
            pg_class.oid as "tableOid",
            pg_class.relname as "tableName",
            pg_attribute.attname as "colName",
            pg_type.typname as "colType",
            pg_attribute.attnum as "colNum",
            pg_attribute.atthasdef "colHasDef",
            pg_attribute.attnotnull "colNotNull"
        FROM
            pg_attribute,
            pg_class,
            pg_type
        WHERE TRUE
            AND pg_attribute.attrelid = pg_class.oid
            AND pg_attribute.atttypid = pg_type.oid
            AND pg_attribute.attnum >= 1
        ORDER BY
            pg_class.relname,
            pg_attribute.attname
    `;
    return rows;
}
//# sourceMappingURL=generate.js.map