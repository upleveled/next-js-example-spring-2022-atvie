"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateTestDatabaseName = exports.setupTestDatabase = exports.mapConnectionOptionsToString = void 0;
const shared_1 = require("@ts-safeql/shared");
const child_process_1 = require("child_process");
const nanoid_1 = require("nanoid");
const pg_connection_string_1 = require("pg-connection-string");
const postgres_1 = __importDefault(require("postgres"));
function mapConnectionOptionsToString(connectionOptions) {
    return `postgres://${connectionOptions.user}:${connectionOptions.password}@${connectionOptions.host}:${connectionOptions.port}/${connectionOptions.database}`;
}
exports.mapConnectionOptionsToString = mapConnectionOptionsToString;
async function setupTestDatabase(params) {
    const connection = Object.assign(Object.assign({}, parseConnection(params.postgresUrl)), { database: params.databaseName });
    const drop = () => dropDatabase(connection);
    const sql = (0, postgres_1.default)(connection);
    await initDatabase(connection);
    const databaseUrl = mapConnectionOptionsToString(connection);
    return { drop, sql, databaseUrl: databaseUrl, databaseName: params.databaseName };
}
exports.setupTestDatabase = setupTestDatabase;
function generateTestDatabaseName() {
    return `safeql_test_${(0, nanoid_1.nanoid)()}`;
}
exports.generateTestDatabaseName = generateTestDatabaseName;
function parseConnection(databaseUrl) {
    const connection = (0, pg_connection_string_1.parse)(databaseUrl);
    if (connection.host === null) {
        throw new Error("Could not resolve database host");
    }
    if (!(0, shared_1.isDefined)(connection.port)) {
        throw new Error("Could not resolve database port");
    }
    if (!(0, shared_1.isDefined)(connection.user)) {
        throw new Error("Could not resolve database user");
    }
    if (!(0, shared_1.isDefined)(connection.password)) {
        throw new Error("Could not resolve datbase password");
    }
    if (!(0, shared_1.isDefined)(connection.database)) {
        throw new Error("Could not resolve database name");
    }
    return {
        host: connection.host,
        port: parseInt(connection.port, 10),
        user: connection.user,
        password: connection.password,
        database: connection.database,
    };
}
async function initDatabase(connection) {
    try {
        try {
            await dropDatabase(connection);
        }
        catch (_a) {
            // do nothing
        }
        await createDatabase(connection);
    }
    catch (e) {
        if (!(e instanceof Error)) {
            throw e;
        }
        console.log(-1);
        console.error("Failed initializing database:", e.toString());
    }
}
function createDatabase(connection) {
    const exec = (0, child_process_1.spawn)("createdb", [
        connection.database,
        "-h",
        connection.host,
        "-p",
        connection.port.toString(),
        "-U",
        connection.user,
    ], {
        env: Object.assign(Object.assign({}, process.env), { PGPASSWORD: connection.password }),
    });
    return new Promise((resolve, reject) => {
        exec.stderr.on("data", (x) => reject(x.toString()));
        exec.on("exit", (code) => (code === 0 ? resolve(code) : reject(code)));
    });
}
function dropDatabase(connection) {
    const exec = (0, child_process_1.spawn)("dropdb", [
        connection.database,
        "--if-exists",
        "-h",
        connection.host,
        "-p",
        connection.port.toString(),
        "-U",
        connection.user,
    ], {
        env: Object.assign(Object.assign({}, process.env), { PGPASSWORD: connection.password }),
    });
    return new Promise((resolve, reject) => {
        exec.stderr.on("data", (x) => reject(x.toString()));
        exec.on("exit", (code) => (code === 0 ? resolve(code) : reject(code)));
    });
}
//# sourceMappingURL=setup-test-database.js.map