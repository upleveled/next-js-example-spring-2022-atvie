"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeMembersToString = exports.typeElementsToString = exports.tsTypeToText = void 0;
const utils_1 = require("@typescript-eslint/utils");
function tsTypeToText(params) {
    const { checker, parser, typeNode } = params;
    if (typeNode.type === utils_1.TSESTree.AST_NODE_TYPES.TSTypeLiteral) {
        return typeElementsToString({
            checker: checker,
            parser: parser,
            elements: typeNode.members,
        });
    }
    if (typeNode.type === utils_1.TSESTree.AST_NODE_TYPES.TSTypeReference) {
        const type = checker.getTypeFromTypeNode(parser.esTreeNodeToTSNodeMap.get(typeNode));
        return typeMembersToString({
            checker: checker,
            members: type.symbol.members,
        });
    }
    if (typeNode.type === utils_1.TSESTree.AST_NODE_TYPES.TSArrayType) {
        return tsTypeToText({ checker, parser, typeNode: typeNode.elementType }) + "[]";
    }
    return "UNKNOWN";
}
exports.tsTypeToText = tsTypeToText;
function typeElementsToString(params) {
    const { elements, parser, checker } = params;
    const entries = [];
    for (const element of elements) {
        if (element.type === utils_1.TSESTree.AST_NODE_TYPES.TSPropertySignature &&
            element.key.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
            const key = element.key.name;
            const tsNode = parser.esTreeNodeToTSNodeMap.get(element);
            const type = checker.getTypeAtLocation(tsNode);
            const typeString = checker.typeToString(type);
            entries.push({ key, type: typeString });
        }
    }
    return mapEntriesToInlineLiteralTypeString(entries);
}
exports.typeElementsToString = typeElementsToString;
function typeMembersToString(params) {
    const { checker, members } = params;
    const entries = [];
    members === null || members === void 0 ? void 0 : members.forEach((value, key) => {
        const type = checker.getTypeOfSymbolAtLocation(value, value.valueDeclaration);
        const typeString = checker.typeToString(type);
        entries.push({ key: key.toString(), type: typeString });
    });
    if (entries.length === 0) {
        return null;
    }
    return mapEntriesToInlineLiteralTypeString(entries);
}
exports.typeMembersToString = typeMembersToString;
function mapEntriesToInlineLiteralTypeString(entries) {
    return `{ ${entries.map(({ key, type }) => `${key}: ${type};`).join(" ")} }`;
}
//# sourceMappingURL=ts.utils.js.map